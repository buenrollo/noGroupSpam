import { Injectable } from '@angular/core';
import { ValenciaYBuenRolloApiRest } from '../api/valenciaybuenrollo-api-rest';
import { Observable, Subscriber } from 'rxjs';
import { FirebaseUtils } from '../../shared/utils/firebase-utils';
import { LocalDate } from 'src/app/shared/localdate/model/localdate';
import { DateUtils } from 'src/app/shared/localdate/date-utils';
import { retry } from 'rxjs/operators';
import { GamingEventsDay, GamingEvent, GamingEventInfo } from '../../../shared/models/events/event/gaming/gamingEvent';
import { BOEvents } from './bussiness-operations/events/bo-events';

@Injectable({
  providedIn: 'root'
})
export abstract class FirebaseApiService {

  constructor(private firebase: ValenciaYBuenRolloApiRest, private firebaseUtils: FirebaseUtils) { }

  public events = new BOEvents(this.firebase.events, this.firebaseUtils);

  public getEvents(type: string) {
    return this.events.get(type);
  }

  public getGameEvents(): Observable<GamingEventsDay[]> {
    return new Observable(subscriber => {
      // this.firebase.getAllGamingEvents().subscribe({
        this.firebase.events.gaming.get.all().subscribe({
        next: (x) => {
          const eventsList: GamingEventsDay[] = [];
          if (x === null) {
            subscriber.error([]);
            subscriber.complete();
          } else {
            const dayKeys = Object.keys(x);
            const currentDate = this.firebaseUtils.generateIdByDate(
              new DateUtils().currentDateChangeAtSpainHour(5)
            );
            dayKeys.forEach(day => {
              if (this.checkEventinTime(day, currentDate)) {
                const eventsDay: GamingEventsDay = {
                  idDay: day,
                  events: []
                };
                const eventskeys = Object.keys(x[day]);
                eventskeys.forEach(id => {
                  const event: GamingEvent = {
                    id, info: x[day][id]
                  };
                  eventsDay.events.push(event);
                });
                eventsList.push(eventsDay);
              } else {
                this.moveOldEvent(day, x[day]);

              }
            });
            subscriber.next(eventsList);
            subscriber.complete();
          }
        },
        error: (err) => {
          subscriber.error([]);
          subscriber.complete();
        }
      });
    });
  }

  public getGameEvent(idDay: number, id: string): Observable<GamingEventInfo> {
    return this.firebase.events.gaming.get.event(idDay, id);
  }

  public getImageEvent(type: string, idDay: number, id: string): Observable<string> {
    return this.firebase.events.gaming.get.imageThumbnail(idDay, id);
  }

  public getGameEventsOld(): Observable<GamingEvent[]> {
    return new Observable(subscriber => {
      this.firebase.events.gaming.get.all().subscribe({
        next: (x) => {
          const eventsList: GamingEvent[] = [];
          if (x === null) {
            subscriber.error([]);
            subscriber.complete();
          } else {
            const dayKeys = Object.keys(x);
            const currentDate = this.firebaseUtils.generateIdByDate(
              new DateUtils().currentDateChangeAtSpainHour(5)
            );
            dayKeys.forEach(day => {
              if (this.checkEventinTime(day, currentDate)) {
                const eventskeys = Object.keys(x[day]);
                eventskeys.forEach(id => {
                  const event: GamingEvent = {
                    id, info: x[day][id]
                  };
                  eventsList.push(event);
                });
              } else {
                this.moveOldEvent(day, x[day]);

              }
            });
            subscriber.next(eventsList);
            subscriber.complete();
          }
        },
        error: (err) => {
          subscriber.error([]);
          subscriber.complete();
        }
      });
    });
  }

  private checkEventinTime(day: string, currentDate: number) {
    let result = false;
    const daysToEvent = parseInt(day, 10) - currentDate;
    console.log('Resultado de fecha: ' + currentDate);
    if (daysToEvent >= 0) {
      result = true;
    }
    return result;
  }

  private moveOldEvent(id: string, event: any) {
    // this.firebase.moveOldEvent(type, id, event);
    this.firebase.events.gaming.moveOld(id, event);
  }

  public createGamingEvent(event: GamingEventInfo): Observable<any> {
    const idDay: number = this.firebaseUtils.generateIdByDate(event.date);
    return this.addIdToInfo(
      this.firebase.events.gaming.post.event(idDay, event),
      idDay
    );
  }

  private addIdToInfo(obervable: Observable<any>, id: number) {
    return new Observable(subscriber => {
      obervable.subscribe({
        next: (info) => {
          subscriber.next({
            id,
            info
          });
        },
        error: (err) => {
          subscriber.error(err);
        }
      });
    });
  }

  public statusGamingEvent(status: boolean, date: LocalDate, id: string) {
    const idDay: number = this.firebaseUtils.generateIdByDate(date);
    return this.addIdToInfo(
      this.firebase.events.gaming.patch.status(status, idDay, id),
      idDay
    );
  }

  public updateGamingEvent(id: string, event: GamingEventInfo, oldDate: LocalDate) {
    return new Observable(subscriber => {
      const idDay: number = this.firebaseUtils.generateIdByDate(event.date);
      const oldDay: number = this.firebaseUtils.generateIdByDate(oldDate);
      // if date is diferent we need to move participants too and delete old event.
      if (idDay !== oldDay) {
        const types = this.firebase.events.participantTypes.getTypes();
        let i = 0;
        const end = types.length;
        types.forEach(type => {
          this.firebase.events.gaming.get.allParticipants(oldDay, id, type).subscribe({
            next: (particpants: { [id: string]: string } ) => {
              i++;
              event[type] = particpants;
              if (i === end) {
                this.firebase.events.gaming.patch.event(idDay, id, event).subscribe({
                  next: (x) => {
                    this.firebase.events.gaming.delete.event(oldDay, id).pipe(
                      retry(5)
                    ).subscribe({
                      next: (info) => {
                        subscriber.next({
                          id: idDay,
                          info
                        });
                      }, error: (err) => {
                        subscriber.error('No se ha podido borrar la quedada del ' +
                          oldDate.day + '/' + oldDate.month + ' por lo que ahora hay dos quedas.'
                        );
                      }
                    });
                  },
                  error: (err) => {
                    subscriber.error('Error al modificar la quedada, Vuelva a intentarlo.');
                  }
                });
              }
            },
            error: (err) => {
              subscriber.error('Error obteniendo los participantes de la quedada. Vuelva a intentarlo.') ;
            }
          });
        });
      } else {
        this.firebase.events.gaming.patch.event(idDay, id, event).subscribe({
          next: (info) => {
            subscriber.next({
              id: idDay,
              info
            });
          }, error: (err) => {
            subscriber.error('Error al modificar la quedada, Vuelva a intentarlo.');
          }
        });
      }
    });
  }

  public addGamingEventEnrolled(event: GamingEvent, names: string[]) {
    const idDay = this.firebaseUtils.generateIdByDate(event.info.date);
    const idEvent = event.id;
    const continuar = new Observable(subscriber => {
      this.checkGamingEventFreePlaces(idDay, idEvent).subscribe({
        next: (x) => {
          if (x >= 0 && x < names.length) {
            subscriber.error('There are not enough spot left');
            subscriber.complete();
          } else {
            subscriber.next();
            subscriber.complete();
          }
        },
        error: (err) => {
          subscriber.error(err);
          subscriber.complete();
        }
      });
    });

    return new Observable(subscriber => {
      continuar.subscribe({
        next: (x) => {
          this.postGamingEventParticipant(idDay, idEvent, names, 'enrolled').subscribe({
            next: (result) => {
              subscriber.next(result);
              subscriber.complete();
            },
            error: (err) => {
              subscriber.error(err);
              subscriber.complete();
            }
          });
        },
        error: (err) => {
          subscriber.error(err);
          subscriber.complete();
        }
      });
    });
  }

  public addGamingEventReserves(event: GamingEvent, names: string[]) {
    return this.postGamingEventParticipant(
      this.firebaseUtils.generateIdByDate(event.info.date),
      event.id,
      names, 'reserves'
    );
  }

  public addGamingEventMaybe(event: GamingEvent, names: string[]) {
    return this.postGamingEventParticipant(
      this.firebaseUtils.generateIdByDate(event.info.date),
      event.id,
      names, 'maybe'
    );
  }

  private checkGamingEventFreePlaces(idDay: number, idEvent: string) {
    return new Observable(subscriber => {
      this.firebase.events.gaming.get.event(idDay, idEvent).subscribe({
        next: (x: GamingEventInfo) => {
          let limit = -1;
          if (x.limit && x.limit > 0) {
            if (x.enrolled) {
              limit = x.limit - Object.keys(x.enrolled).length;
            } else {
              limit = x.limit;
            }
          }
          subscriber.next(limit);
          subscriber.complete();
        },
        error: (err) => {
          subscriber.error(err);
          subscriber.complete();
        }
      });
    });
  }

  private postGamingEventParticipant(idDay: number, idEvent: string, names: string[], type: string) {
    return new Observable(subscriber => {
      let count = 0; // used to count the number of games fixed.
      const finish = names.length; // used to know the amount of games to fix.
      let errors = 0;
      names.forEach(name => {
        name = '"' + name + '"';
        this.firebase.events.gaming.post.participant(idDay, idEvent, name, type).subscribe({
          next: () => {
            count++;
            this.checkIfSubscriberIsFinished(subscriber, count, finish, errors, 'Error adding ' + errors + ' ' + type + '.');
          },
          error: (err) => {
            count++;
            errors++;
            this.checkIfSubscriberIsFinished(subscriber, count, finish, errors, 'Error adding ' + errors + ' ' + type + '.');
          }
        });
      });
    });
  }

  /**
   * If count is equal to finish subscriber must send next event if there are no errors, otherwise send error event.
   * @param subscriber Subscriber that must do the actions.
   * @param count Number with the counter to know if subscriber must send the action.
   * @param finish Number to compare with counter to know if subscriber must send the action.
   * @param errors Number of errors in subscriber.
   * @param errorMessage Error message that will launch if there are errors.
   */
  private checkIfSubscriberIsFinished(subscriber: Subscriber<any>, count: number, finish: number, errors: number, errorMessage: string) {
    if (count === finish) {
      if ( errors === 0 ) {
        subscriber.next(true);
        subscriber.complete();
      } else {
        subscriber.error(errorMessage);
        subscriber.complete();
      }
    }
  }

  public editGamingEventEnrolled(event: GamingEvent, key: string, value: string, type: string) {
    const idDay = this.firebaseUtils.generateIdByDate(event.info.date);
    const idEvent = event.id;

    const check = new Observable(subscriber => {
      this.firebase.events.gaming.get.participant(idDay, idEvent, type, key).subscribe({
        next: (x) => {
          if (x !== null) {
            subscriber.next();
            subscriber.complete();
          } else {
            subscriber.error('Partifipant ' + key + ' not found in ' + type + ' list.');
            subscriber.complete();
          }
        },
        error: (err) => {
          subscriber.error(err);
          subscriber.complete();
        }
      });
    });

    return new Observable(subscriber => {
      check.subscribe({
        next: (x) => {
          const patch = this.firebase.events.gaming.patch.participant(
            this.firebaseUtils.generateIdByDate(event.info.date),
            event.id,
            key,
            value,
            type
          );
          this.dispatchResponse(patch, subscriber);
        }, error: (err) => {
          subscriber.error(err);
          subscriber.complete();
        }
      });
    });
  }

  public getGamingEventAllParticipants(event: GamingEvent, type: string) {
    const idDay = this.firebaseUtils.generateIdByDate(event.info.date);
    const idEvent = event.id;

    return this.firebase.events.gaming.get.allParticipants(idDay, idEvent, type);
  }

  public deleteGamingEventParticipant(event: GamingEvent, type: string, key: string) {
    return this.firebase.events.gaming.delete.participant(
      this.firebaseUtils.generateIdByDate(event.info.date),
      event.id,
      type,
      key
    );
  }

  private dispatchResponse(comunication: Observable<any>, subscriber: Subscriber<any>) {
    comunication.subscribe({
      next: (x: any) => {
        subscriber.next(x);
        subscriber.complete();
      },
      error: (err: any) => {
        subscriber.error(err);
        subscriber.complete();
      }
    });
  }
}
